#include <iostream>
#include <string>
#include <xstring.h>
#include <windows.h>
#include <random>
#include <ctime>
#include "dcsa1.h"

void NullString(char* str, size_t len)
{
	for (size_t i = 0; i < len; i++)
		str[i] = 0;
}

int GetRandomBetween(int a, int b)
{
	static bool rinit = false;
	static std::default_random_engine generator;
	if (!rinit)
	{
		generator.seed((UINT)time(NULL));
		rinit = true;
	}
	std::uniform_int_distribution<int> distribution(a, b);
	int dice_roll = distribution(generator);
	return dice_roll;
}


int main()
{
#ifdef _DEBUG
	std::cout << "Press any key when you connect debugger..." << std::endl;
 	system("pause");
#endif
	DWORD dw = 0;
	HANDLE hFile = NULL;

	size_t key1_size = GetRandomBetween(27, 179);
	size_t key2_size = GetRandomBetween(27, 179);
	size_t key3_size = GetRandomBetween(27, 179);
	size_t key4_size = GetRandomBetween(27, 179);
	size_t key5_size = GetRandomBetween(27, 179);

	BYTE* key1 = new BYTE[key1_size]; //dll
	BYTE* key2 = new BYTE[key2_size]; //upd
	BYTE* key3 = new BYTE[key3_size]; //vtf
	BYTE* key4 = new BYTE[key4_size]; //vmt
	BYTE* key5 = new BYTE[key5_size]; //snd

	for(size_t i = 0; i < key1_size; i++)
		key1[i] = GetRandomBetween(0, 255);

	for (size_t i = 0; i < key2_size; i++)
		key2[i] = GetRandomBetween(0, 255);

	for (size_t i = 0; i < key3_size; i++)
		key3[i] = GetRandomBetween(0, 255);

	for (size_t i = 0; i < key4_size; i++)
		key4[i] = GetRandomBetween(0, 255);

	for (size_t i = 0; i < key5_size; i++)
		key5[i] = GetRandomBetween(0, 255);

	std::string output_name;
	int filetype;

		hFile = CreateFile("system32.dll", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (!hFile || hFile == (HANDLE)0xffffffff)
		{
			upd:
			hFile = CreateFile("update.exe", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
			if (!hFile || hFile == (HANDLE)0xffffffff)
			{
				vtf:
				hFile = CreateFile("textures\\eye.vtf", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
				if (!hFile || hFile == (HANDLE)0xffffffff)
				{
					vmt:
					hFile = CreateFile("textures\\eye.vmt", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
					if (!hFile || hFile == (HANDLE)0xffffffff)
					{
						snd:
						hFile = CreateFile("sounds\\spotted.wav", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
						if (!hFile || hFile == (HANDLE)0xffffffff)
						{
							std::cout << "Fiels system32.dll, update.exe, eye.vtf, eye.vmt and spotted.wav has been no found..." << std::endl;
							system("pause");
							return 0;
						}
						else
						{
							output_name = "00000004";
							remove("00000004");
							filetype = 4;
							std::cout << "---spotted.wav---" << std::endl;
						}
					}
					else
					{
						output_name = "00000003";
						remove("00000003");
						filetype = 3;
						std::cout << "---eye.vmt---" << std::endl;
					}

				}
				else
				{
					output_name = "00000002";
					remove("00000002");
					filetype = 2;
					std::cout << "---eye.vtf---" << std::endl;
				}
			}
			else
			{
				output_name = "00000001";
				remove("00000001");
				filetype = 1;
				std::cout << "---update.exe---" << std::endl;
			}
		}
		else
		{
			output_name = "00000000";
			remove("00000000");
			filetype = 0;
			std::cout << "---system32.dll---" << std::endl;
		}

	std::cout << "Encrypting..." << std::endl;
	//const int KEY_SIZE = 28;
	//BYTE key1[KEY_SIZE] = "Ib0$f7f2d!3$v9ZjQq(57f8x3P#"; key1[KEY_SIZE - 1] = 'E';
	//BYTE key2[KEY_SIZE] = "f7d28f#x(Pj30$Q$EI!v5f7bq3b"; key2[KEY_SIZE - 1] = '6';
	

	size_t file_size = GetFileSize(hFile, NULL);
	BYTE* file_buffer = new BYTE[file_size];
	BYTE* encrypted_buffer = new BYTE[file_size];



	char numbuf[16] = "";
	xstringA keylib_cont;

	keylib_cont.Append("//Generated by encryptor\r\n");
	keylib_cont.Append("\r\n");
	keylib_cont.Append("#ifndef _XORKEYS_H_\r\n");
	keylib_cont.Append("#define _XORKEYS_H_\r\n");
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned int _DllXorKeySize = %u;", key1_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned int _UpdXorKeySize = %u;", key2_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned int _eyeVtfKeySize = %u;", key3_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned int _eyeVmtKeySize = %u;", key4_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned int _sndKeySize = %u;", key5_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned char _DllXorKey[_DllXorKeySize] = { %#trX(, ) };", key1, key1_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned char _UpdXorKey[_UpdXorKeySize] = { %#trX(, ) };", key2, key2_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned char _eyeVtfKey[_eyeVtfKeySize] = { %#trX(, ) };", key3, key3_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned char _eyeVmtKey[_eyeVmtKeySize] = { %#trX(, ) };", key4, key4_size);
	keylib_cont.Append("\r\n");
	keylib_cont.AppendFormat("const unsigned char _sndKey[_sndKeySize] = { %#trX(, ) };", key5, key5_size);
	keylib_cont.Append("\r\n");
	keylib_cont.Append("\r\n");
	keylib_cont.Append("#endif");


	ReadFile(hFile, file_buffer, file_size, &dw, NULL);
	CloseHandle(hFile);

	size_t k = 0, kk = 1;
	switch(filetype)
	{
	case 0:
		for (size_t i = 0; i < file_size; i++)
		{
			encrypted_buffer[i] = file_buffer[i] ^ key1[k];
			k++;
			if (k == key1_size)
				k = 0;

			encrypted_buffer[i] = encrypted_buffer[i] ^ key1[kk];
			kk++;
			if (kk == key1_size)
				kk = 0;
		}
		break;
		
	case 1:
		k = 0; kk = 1;
		for (size_t i = 0; i < file_size; i++)
		{
			encrypted_buffer[i] = file_buffer[i] ^ key2[k];
			k++;
			if (k == key2_size)
				k = 0;

			encrypted_buffer[i] = encrypted_buffer[i] ^ key2[kk];
			kk++;
			if (kk == key2_size)
				kk = 0;
		}
		break;

	case 2:
		k = 0; kk = 1;
		for (size_t i = 0; i < file_size; i++)
		{
			encrypted_buffer[i] = file_buffer[i] ^ key3[k];
			k++;
			if (k == key3_size)
				k = 0;

			encrypted_buffer[i] = encrypted_buffer[i] ^ key3[kk];
			kk++;
			if (kk == key3_size)
				kk = 0;
		}
		break;

	case 3:
		k = 0; kk = 1;
		for (size_t i = 0; i < file_size; i++)
		{
			encrypted_buffer[i] = file_buffer[i] ^ key4[k];
			k++;
			if (k == key4_size)
				k = 0;

			encrypted_buffer[i] = encrypted_buffer[i] ^ key4[kk];
			kk++;
			if (kk == key4_size)
				kk = 0;
		}
		break;

	case 4:
		k = 0; kk = 1;
		for (size_t i = 0; i < file_size; i++)
		{
			encrypted_buffer[i] = file_buffer[i] ^ key5[k];
			k++;
			if (k == key5_size)
				k = 0;

			encrypted_buffer[i] = encrypted_buffer[i] ^ key5[kk];
			kk++;
			if (kk == key5_size)
				kk = 0;
		}
		break;

	default:
		__assume(0);

	}

	delete[] file_buffer;
	 
	std::cout << "Writing to file..." << std::endl;
	hFile = CreateFile(output_name.c_str(), GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile(hFile, encrypted_buffer, file_size, &dw, NULL);
	delete[] encrypted_buffer;
	CloseHandle(hFile);
	std::cout << "Success! Encrypted file called as " << output_name << std::endl;

	switch (filetype)
	{
		case 0:
			goto upd;
			break;

		case 1:
			goto vtf;
			break;

		case 2:
			goto vmt;
			break;
		case 3:
			goto snd;
			break;
		case 4:
			break;

		default:
			__assume(0);
	}

	remove("xorkeys.h");
	hFile = CreateFile("xorkeys.h", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	WriteFile(hFile, keylib_cont.GetStr().c_str(), keylib_cont.GetLen(), &dw, NULL);
	CloseHandle(hFile);
	std::cout << "************************************" << std::endl;
	std::cout << "Encryption keys saved in file xorkeys.h" << std::endl;

	//std::cout << "************************************" << std::endl;
	//std::cout << "\"\"->" << DCSA1::HashString("").GetStr() << std::endl;
	//std::cout << "\"zalypa\"->" << DCSA1::HashString("zalypa").GetStr() << std::endl;
	//std::cout << "\"zalYpa\"->" << DCSA1::HashString("zalYpa").GetStr() << std::endl;
	//std::cout << "\"hfdhsdffh239th23g8hgio23hgj23i9hg23iohy239283ogh2389hygh2giu23hg9823\"->" << DCSA1::HashString("hfdhsdffh239th23g8hgio23hgj23i9hg23iohy239283ogh2389hygh2giu23hg9823").GetStr() << std::endl;
	delete[] key1;
	delete[] key2;
	system("pause");
	return 0;
}